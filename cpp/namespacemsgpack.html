<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MessagePack for C++: msgpack Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MessagePack for C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">msgpack Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemsgpack_1_1adaptor"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack_1_1adaptor.html">adaptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemsgpack_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemsgpack_1_1type"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack_1_1type.html">type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1packer.html">packer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template that supports continuous packing.  <a href="classmsgpack_1_1packer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1container__size__overflow.html">container_size_overflow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_std_tuple_packer.html">StdTuplePacker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_std_tuple_packer_3_01_stream_00_01_tuple_00_010_01_4.html">StdTuplePacker&lt; Stream, Tuple, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_std_tuple_as.html">StdTupleAs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_std_tuple_as_impl.html">StdTupleAsImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_std_tuple_as_3_4.html">StdTupleAs&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_std_tuple_converter.html">StdTupleConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_std_tuple_converter_3_01_tuple_00_010_01_4.html">StdTupleConverter&lt; Tuple, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_std_tuple_to_object_with_zone.html">StdTupleToObjectWithZone</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_std_tuple_to_object_with_zone_3_01_tuple_00_010_01_4.html">StdTupleToObjectWithZone&lt; Tuple, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_msgpack_tuple_packer.html">MsgpackTuplePacker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_msgpack_tuple_packer_3_01_stream_00_01_tuple_00_011_01_4.html">MsgpackTuplePacker&lt; Stream, Tuple, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_msgpack_tuple_packer_3_01_stream_00_01_tuple_00_010_01_4.html">MsgpackTuplePacker&lt; Stream, Tuple, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_msgpack_tuple_as_impl.html">MsgpackTupleAsImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_msgpack_tuple_as.html">MsgpackTupleAs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_msgpack_tuple_as_3_4.html">MsgpackTupleAs&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_msgpack_tuple_converter.html">MsgpackTupleConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_msgpack_tuple_converter_3_01_tuple_00_011_01_4.html">MsgpackTupleConverter&lt; Tuple, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_msgpack_tuple_converter_3_01_tuple_00_010_01_4.html">MsgpackTupleConverter&lt; Tuple, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_msgpack_tuple_to_object_with_zone.html">MsgpackTupleToObjectWithZone</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_msgpack_tuple_to_object_with_zone_3_01_tuple_00_011_01_4.html">MsgpackTupleToObjectWithZone&lt; Tuple, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1_msgpack_tuple_to_object_with_zone_3_01_tuple_00_010_01_4.html">MsgpackTupleToObjectWithZone&lt; Tuple, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1zone.html">zone</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1fbuffer.html">fbuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1seq.html">seq</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1gen__seq.html">gen_seq</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1gen__seq_3_010_00_01_is_8_8_8_01_4.html">gen_seq&lt; 0, Is... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1is__non__const__pointer.html">is_non_const_pointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1object__kv.html">object_kv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1object__handle.html">object_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class holds object and zone.  <a href="classmsgpack_1_1object__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1object__parser.html">object_parser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1object__pack__visitor.html">object_pack_visitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1object__stringize__visitor.html">object_stringize_visitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1aligned__zone__size__visitor.html">aligned_zone_size_visitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1define.html">define</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1object__equal__visitor.html">object_equal_visitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1object__array.html">object_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1object__map.html">object_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1object__str.html">object_str</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1object__bin.html">object_bin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1object__ext.html">object_ext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1has__as.html">has_as</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1object.html">object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object class that corresponding to MessagePack format object.  <a href="structmsgpack_1_1object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1type__error.html">type_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1sbuffer.html">sbuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1unpacker.html">unpacker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacking class for a stream deserialization.  <a href="classmsgpack_1_1unpacker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1unpack__error.html">unpack_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1parse__error.html">parse_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1insufficient__bytes.html">insufficient_bytes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1size__overflow.html">size_overflow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1array__size__overflow.html">array_size_overflow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1map__size__overflow.html">map_size_overflow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1str__size__overflow.html">str_size_overflow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1bin__size__overflow.html">bin_size_overflow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1ext__size__overflow.html">ext_size_overflow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1depth__size__overflow.html">depth_size_overflow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1iovec.html">iovec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1vrefbuffer.html">vrefbuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1zbuffer.html">zbuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsgpack_1_1null__visitor.html">null_visitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1parser.html">parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsing class for a stream deserialization.  <a href="classmsgpack_1_1parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsgpack_1_1basic__unpacker.html">basic_unpacker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a250cf933f89282ba40ed3fa0e61496b6"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class T, class... U&gt; </td></tr>
<tr class="memitem:a250cf933f89282ba40ed3fa0e61496b6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a250cf933f89282ba40ed3fa0e61496b6">all_of</a> = <a class="el" href="structmsgpack_1_1detail_1_1all__of__imp.html">detail::all_of_imp</a>&lt; T&lt; U &gt;::value... &gt;</td></tr>
<tr class="separator:a250cf933f89282ba40ed3fa0e61496b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710137be42540a5133f68416b82af064"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class T, class... U&gt; </td></tr>
<tr class="memitem:a710137be42540a5133f68416b82af064"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a710137be42540a5133f68416b82af064">any_of</a> = <a class="el" href="structmsgpack_1_1detail_1_1any__of__imp.html">detail::any_of_imp</a>&lt;(T&lt; U &gt;::value)... &gt;</td></tr>
<tr class="separator:a710137be42540a5133f68416b82af064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74841406f4ad1b1b1bf51d5290418697"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a>) (<a class="el" href="namespacemsgpack_1_1type.html#aebeb894b31101ddccf113e9ea8063543">msgpack::type::object_type</a> type, std::size_t size, void *user_data)</td></tr>
<tr class="memdesc:a74841406f4ad1b1b1bf51d5290418697"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of reference or copy judging function.  <a href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">More...</a><br /></td></tr>
<tr class="separator:a74841406f4ad1b1b1bf51d5290418697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ab177cb30e697ad240ade7d0f91ceb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classmsgpack_1_1object__handle.html">object_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a50ab177cb30e697ad240ade7d0f91ceb">unpacked</a></td></tr>
<tr class="separator:a50ab177cb30e697ad240ade7d0f91ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad2aa541d4168ec1c937a76b73f26020e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020e">parse_return</a> { <br />
&#160;&#160;<a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea34e4a2c3d4a4d61e3e005d770f9b1f3a">PARSE_SUCCESS</a> = 2
, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea2d14189ec74ce05fa981495fa6fe638f">PARSE_EXTRA_BYTES</a> = 1
, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea11b259f07434bbdbfc0092e51d4b76b1">PARSE_CONTINUE</a> = 0
, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020eae3afbf3256871bb72186fdfcbbaa5141">PARSE_PARSE_ERROR</a> = -1
, <br />
&#160;&#160;<a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea34e4a2c3d4a4d61e3e005d770f9b1f3a">PARSE_SUCCESS</a> = 2
, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea2d14189ec74ce05fa981495fa6fe638f">PARSE_EXTRA_BYTES</a> = 1
, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea11b259f07434bbdbfc0092e51d4b76b1">PARSE_CONTINUE</a> = 0
, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020eae3afbf3256871bb72186fdfcbbaa5141">PARSE_PARSE_ERROR</a> = -1
, <br />
&#160;&#160;<a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea33d5d29228314944dd990a35870aaf3f">PARSE_STOP_VISITOR</a> = -2
<br />
 }</td></tr>
<tr class="separator:ad2aa541d4168ec1c937a76b73f26020e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2aa541d4168ec1c937a76b73f26020e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020e">parse_return</a> { <br />
&#160;&#160;<a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea34e4a2c3d4a4d61e3e005d770f9b1f3a">PARSE_SUCCESS</a> = 2
, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea2d14189ec74ce05fa981495fa6fe638f">PARSE_EXTRA_BYTES</a> = 1
, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea11b259f07434bbdbfc0092e51d4b76b1">PARSE_CONTINUE</a> = 0
, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020eae3afbf3256871bb72186fdfcbbaa5141">PARSE_PARSE_ERROR</a> = -1
, <br />
&#160;&#160;<a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea34e4a2c3d4a4d61e3e005d770f9b1f3a">PARSE_SUCCESS</a> = 2
, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea2d14189ec74ce05fa981495fa6fe638f">PARSE_EXTRA_BYTES</a> = 1
, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea11b259f07434bbdbfc0092e51d4b76b1">PARSE_CONTINUE</a> = 0
, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020eae3afbf3256871bb72186fdfcbbaa5141">PARSE_PARSE_ERROR</a> = -1
, <br />
&#160;&#160;<a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea33d5d29228314944dd990a35870aaf3f">PARSE_STOP_VISITOR</a> = -2
<br />
 }</td></tr>
<tr class="separator:ad2aa541d4168ec1c937a76b73f26020e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aec73610d06debb4a9921afecf13b4586"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec73610d06debb4a9921afecf13b4586"><td class="memTemplItemLeft" align="right" valign="top">msgpack::enable_if&lt; !is_array&lt; T &gt;::value, <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> const  &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#aec73610d06debb4a9921afecf13b4586">operator&gt;&gt;</a> (<a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> const &amp;o, T &amp;v)</td></tr>
<tr class="separator:aec73610d06debb4a9921afecf13b4586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1f207df87c6130921599a44aadeee7"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:abb1f207df87c6130921599a44aadeee7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#abb1f207df87c6130921599a44aadeee7">operator&gt;&gt;</a> (<a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> const &amp;o, T(&amp;v)[N])</td></tr>
<tr class="separator:abb1f207df87c6130921599a44aadeee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4201954718c3c9a46a208e429ef5b359"><td class="memTemplParams" colspan="2">template&lt;typename Stream , typename T &gt; </td></tr>
<tr class="memitem:a4201954718c3c9a46a208e429ef5b359"><td class="memTemplItemLeft" align="right" valign="top">msgpack::enable_if&lt; !is_array&lt; T &gt;::value, <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a4201954718c3c9a46a208e429ef5b359">operator&lt;&lt;</a> (<a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp;o, T const &amp;v)</td></tr>
<tr class="separator:a4201954718c3c9a46a208e429ef5b359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8455b5642bac84788998304025d78e0"><td class="memTemplParams" colspan="2">template&lt;typename Stream , typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:aa8455b5642bac84788998304025d78e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#aa8455b5642bac84788998304025d78e0">operator&lt;&lt;</a> (<a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp;o, const T(&amp;v)[N])</td></tr>
<tr class="separator:aa8455b5642bac84788998304025d78e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b90e1ea7d84b530687b8b933eec8c74"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b90e1ea7d84b530687b8b933eec8c74"><td class="memTemplItemLeft" align="right" valign="top">msgpack::enable_if&lt; !is_array&lt; T &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a0b90e1ea7d84b530687b8b933eec8c74">operator&lt;&lt;</a> (<a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;o, T const &amp;v)</td></tr>
<tr class="separator:a0b90e1ea7d84b530687b8b933eec8c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df79ce87fe26fffeecd5bdc41ce7f00"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a9df79ce87fe26fffeecd5bdc41ce7f00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a9df79ce87fe26fffeecd5bdc41ce7f00">operator&lt;&lt;</a> (msgpack::v1::object &amp;o, const T(&amp;v)[N])</td></tr>
<tr class="separator:a9df79ce87fe26fffeecd5bdc41ce7f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accacd7e7e5a196fb3452a8a744e14213"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:accacd7e7e5a196fb3452a8a744e14213"><td class="memTemplItemLeft" align="right" valign="top">msgpack::enable_if&lt; !is_array&lt; T &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#accacd7e7e5a196fb3452a8a744e14213">operator&lt;&lt;</a> (<a class="el" href="structmsgpack_1_1object_1_1with__zone.html">msgpack::object::with_zone</a> &amp;o, T const &amp;v)</td></tr>
<tr class="separator:accacd7e7e5a196fb3452a8a744e14213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cc917bec1e9289d3d6da0b09d8c9a7"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a59cc917bec1e9289d3d6da0b09d8c9a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a59cc917bec1e9289d3d6da0b09d8c9a7">operator&lt;&lt;</a> (<a class="el" href="structmsgpack_1_1object_1_1with__zone.html">msgpack::object::with_zone</a> &amp;o, const T(&amp;v)[N])</td></tr>
<tr class="separator:a59cc917bec1e9289d3d6da0b09d8c9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5b31bf2abe509e59041696de091dd4"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a0c5b31bf2abe509e59041696de091dd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a0c5b31bf2abe509e59041696de091dd4">operator&lt;&lt;</a> (<a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;o, const T(&amp;v)[N])</td></tr>
<tr class="separator:a0c5b31bf2abe509e59041696de091dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49d09a4923b1fe9a8951bec4ce19d62"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac49d09a4923b1fe9a8951bec4ce19d62"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#ac49d09a4923b1fe9a8951bec4ce19d62">checked_get_container_size</a> (T size)</td></tr>
<tr class="separator:ac49d09a4923b1fe9a8951bec4ce19d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d45dde870073a0e887745d2d2a36f5e"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a2d45dde870073a0e887745d2d2a36f5e">aligned_size</a> (std::size_t size, std::size_t align)</td></tr>
<tr class="separator:a2d45dde870073a0e887745d2d2a36f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52c02be11a42c58799707aa0b71ca4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmsgpack_1_1object__kv.html">msgpack::object_kv</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#ad52c02be11a42c58799707aa0b71ca4e">begin</a> (<a class="el" href="structmsgpack_1_1object__map.html">msgpack::object_map</a> &amp;map)</td></tr>
<tr class="separator:ad52c02be11a42c58799707aa0b71ca4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b8e847a886a176e07d7196704460a0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmsgpack_1_1object__kv.html">msgpack::object_kv</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a24b8e847a886a176e07d7196704460a0">begin</a> (const <a class="el" href="structmsgpack_1_1object__map.html">msgpack::object_map</a> &amp;map)</td></tr>
<tr class="separator:a24b8e847a886a176e07d7196704460a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9426a4160106ee0a2574c731656ea9ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmsgpack_1_1object__kv.html">msgpack::object_kv</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a9426a4160106ee0a2574c731656ea9ac">end</a> (<a class="el" href="structmsgpack_1_1object__map.html">msgpack::object_map</a> &amp;map)</td></tr>
<tr class="separator:a9426a4160106ee0a2574c731656ea9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30d076b7c0675b902871d3784e6cfad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmsgpack_1_1object__kv.html">msgpack::object_kv</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#aa30d076b7c0675b902871d3784e6cfad">end</a> (const <a class="el" href="structmsgpack_1_1object__map.html">msgpack::object_map</a> &amp;map)</td></tr>
<tr class="separator:aa30d076b7c0675b902871d3784e6cfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe35d89e3cc78ab06526e501d8604d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#aefe35d89e3cc78ab06526e501d8604d3">begin</a> (<a class="el" href="structmsgpack_1_1object__array.html">msgpack::object_array</a> &amp;array)</td></tr>
<tr class="separator:aefe35d89e3cc78ab06526e501d8604d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8cffa75e7341c0b1a3fd305fe0899f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#aff8cffa75e7341c0b1a3fd305fe0899f">begin</a> (const <a class="el" href="structmsgpack_1_1object__array.html">msgpack::object_array</a> &amp;array)</td></tr>
<tr class="separator:aff8cffa75e7341c0b1a3fd305fe0899f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d68932a92c29b8bbb18e2ce0f78f65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a19d68932a92c29b8bbb18e2ce0f78f65">end</a> (<a class="el" href="structmsgpack_1_1object__array.html">msgpack::object_array</a> &amp;array)</td></tr>
<tr class="separator:a19d68932a92c29b8bbb18e2ce0f78f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa730ad9ebd655c74ec9dc2dc6f63830b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#aa730ad9ebd655c74ec9dc2dc6f63830b">end</a> (const <a class="el" href="structmsgpack_1_1object__array.html">msgpack::object_array</a> &amp;array)</td></tr>
<tr class="separator:aa730ad9ebd655c74ec9dc2dc6f63830b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dd172d5ccb1d4acb6b6a8f3fc3e176"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a68dd172d5ccb1d4acb6b6a8f3fc3e176">aligned_zone_size</a> (<a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> const &amp;obj)</td></tr>
<tr class="separator:a68dd172d5ccb1d4acb6b6a8f3fc3e176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecc1ef629295f23da063193cb92bd92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1object__handle.html">object_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a5ecc1ef629295f23da063193cb92bd92">clone</a> (<a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> const &amp;obj)</td></tr>
<tr class="memdesc:a5ecc1ef629295f23da063193cb92bd92"><td class="mdescLeft">&#160;</td><td class="mdescRight">clone object  <a href="namespacemsgpack.html#a5ecc1ef629295f23da063193cb92bd92">More...</a><br /></td></tr>
<tr class="separator:a5ecc1ef629295f23da063193cb92bd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7bc570680b8ae0de1c749c8e2613a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a1d7bc570680b8ae0de1c749c8e2613a3">operator==</a> (const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;x, const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;y)</td></tr>
<tr class="separator:a1d7bc570680b8ae0de1c749c8e2613a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbcb500a7141081366c29fe0b981911"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:accbcb500a7141081366c29fe0b981911"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#accbcb500a7141081366c29fe0b981911">operator==</a> (const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;x, const T &amp;y)</td></tr>
<tr class="separator:accbcb500a7141081366c29fe0b981911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3a2a617c1c1ecf19f72f0bfe93b20b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#aec3a2a617c1c1ecf19f72f0bfe93b20b">operator!=</a> (const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;x, const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;y)</td></tr>
<tr class="separator:aec3a2a617c1c1ecf19f72f0bfe93b20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915eca1267162ec5c2f83a77760272cd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a915eca1267162ec5c2f83a77760272cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a915eca1267162ec5c2f83a77760272cd">operator==</a> (const T &amp;y, const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;x)</td></tr>
<tr class="separator:a915eca1267162ec5c2f83a77760272cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96378a28e48ee7da1c3a4fba31dcab08"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a96378a28e48ee7da1c3a4fba31dcab08"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a96378a28e48ee7da1c3a4fba31dcab08">operator!=</a> (const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;x, const T &amp;y)</td></tr>
<tr class="separator:a96378a28e48ee7da1c3a4fba31dcab08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ed2ffbc19708522cef93ebf91840e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad3ed2ffbc19708522cef93ebf91840e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#ad3ed2ffbc19708522cef93ebf91840e5">operator!=</a> (const T &amp;y, const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;x)</td></tr>
<tr class="separator:ad3ed2ffbc19708522cef93ebf91840e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad791b12166312c367396778baf52e949"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad791b12166312c367396778baf52e949"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#ad791b12166312c367396778baf52e949">convert</a> (T &amp;v, <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> const &amp;o)</td></tr>
<tr class="separator:ad791b12166312c367396778baf52e949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129e066299f13283fbf9b35233ca4274"><td class="memTemplParams" colspan="2">template&lt;typename Stream , typename T &gt; </td></tr>
<tr class="memitem:a129e066299f13283fbf9b35233ca4274"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a129e066299f13283fbf9b35233ca4274">pack</a> (<a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp;o, const T &amp;v)</td></tr>
<tr class="separator:a129e066299f13283fbf9b35233ca4274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d65643344f10d9075dec8981ede689"><td class="memTemplParams" colspan="2">template&lt;typename Stream , typename T &gt; </td></tr>
<tr class="memitem:a43d65643344f10d9075dec8981ede689"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a43d65643344f10d9075dec8981ede689">pack_copy</a> (<a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp;o, T v)</td></tr>
<tr class="separator:a43d65643344f10d9075dec8981ede689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f36b156764461cc87047ca6f8997c69"><td class="memTemplParams" colspan="2">template&lt;typename Stream &gt; </td></tr>
<tr class="memitem:a6f36b156764461cc87047ca6f8997c69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a6f36b156764461cc87047ca6f8997c69">operator&lt;&lt;</a> (<a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp;o, const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;v)</td></tr>
<tr class="separator:a6f36b156764461cc87047ca6f8997c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc80c71db083a277afd0f414ccb0d5da"><td class="memTemplParams" colspan="2">template&lt;typename Stream &gt; </td></tr>
<tr class="memitem:acc80c71db083a277afd0f414ccb0d5da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#acc80c71db083a277afd0f414ccb0d5da">operator&lt;&lt;</a> (<a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp;o, const <a class="el" href="structmsgpack_1_1object_1_1with__zone.html">msgpack::object::with_zone</a> &amp;v)</td></tr>
<tr class="separator:acc80c71db083a277afd0f414ccb0d5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edd3e6cd417d3ba840890481235f758"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a9edd3e6cd417d3ba840890481235f758">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;v)</td></tr>
<tr class="separator:a9edd3e6cd417d3ba840890481235f758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a643bd4bc6e81ddf0bdd3ab79402eb5"><td class="memTemplParams" colspan="2">template&lt;typename Stream , typename T &gt; </td></tr>
<tr class="memitem:a3a643bd4bc6e81ddf0bdd3ab79402eb5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a3a643bd4bc6e81ddf0bdd3ab79402eb5">pack</a> (Stream *s, const T &amp;v)</td></tr>
<tr class="memdesc:a3a643bd4bc6e81ddf0bdd3ab79402eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack the value as MessagePack format into the stream.  <a href="namespacemsgpack.html#a3a643bd4bc6e81ddf0bdd3ab79402eb5">More...</a><br /></td></tr>
<tr class="separator:a3a643bd4bc6e81ddf0bdd3ab79402eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0d5514b0618ebde91469fa148e5813"><td class="memTemplParams" colspan="2">template&lt;typename Stream , typename T &gt; </td></tr>
<tr class="memitem:afb0d5514b0618ebde91469fa148e5813"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#afb0d5514b0618ebde91469fa148e5813">pack</a> (Stream &amp;s, const T &amp;v)</td></tr>
<tr class="memdesc:afb0d5514b0618ebde91469fa148e5813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack the value as MessagePack format into the stream.  <a href="namespacemsgpack.html#afb0d5514b0618ebde91469fa148e5813">More...</a><br /></td></tr>
<tr class="separator:afb0d5514b0618ebde91469fa148e5813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c675c74116393a0b90e4dc64d18a0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1object__handle.html">msgpack::object_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#af8c675c74116393a0b90e4dc64d18a0d">unpack</a> (const char *data, std::size_t len, std::size_t &amp;off, bool &amp;referenced, <a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a> f=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, void *user_data=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, <a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const  &amp;limit=<a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>())</td></tr>
<tr class="memdesc:af8c675c74116393a0b90e4dc64d18a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer.  <a href="namespacemsgpack.html#af8c675c74116393a0b90e4dc64d18a0d">More...</a><br /></td></tr>
<tr class="separator:af8c675c74116393a0b90e4dc64d18a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d86345e00d1f7a201a534163644981"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1object__handle.html">msgpack::object_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a49d86345e00d1f7a201a534163644981">unpack</a> (const char *data, std::size_t len, std::size_t &amp;off, <a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a> f=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, void *user_data=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, <a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const  &amp;limit=<a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>())</td></tr>
<tr class="memdesc:a49d86345e00d1f7a201a534163644981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer.  <a href="namespacemsgpack.html#a49d86345e00d1f7a201a534163644981">More...</a><br /></td></tr>
<tr class="separator:a49d86345e00d1f7a201a534163644981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104c8fefce26163d0b7f6467088d6a98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1object__handle.html">msgpack::object_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a104c8fefce26163d0b7f6467088d6a98">unpack</a> (const char *data, std::size_t len, bool &amp;referenced, <a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a> f=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, void *user_data=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, <a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const  &amp;limit=<a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>())</td></tr>
<tr class="memdesc:a104c8fefce26163d0b7f6467088d6a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer.  <a href="namespacemsgpack.html#a104c8fefce26163d0b7f6467088d6a98">More...</a><br /></td></tr>
<tr class="separator:a104c8fefce26163d0b7f6467088d6a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d60c5f750195ba8ed8cab7ceab3ca6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmsgpack_1_1object__handle.html">msgpack::object_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a21d60c5f750195ba8ed8cab7ceab3ca6">unpack</a> (const char *data, std::size_t len, <a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a> f=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, void *user_data=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, <a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const  &amp;limit=<a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>())</td></tr>
<tr class="memdesc:a21d60c5f750195ba8ed8cab7ceab3ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer.  <a href="namespacemsgpack.html#a21d60c5f750195ba8ed8cab7ceab3ca6">More...</a><br /></td></tr>
<tr class="separator:a21d60c5f750195ba8ed8cab7ceab3ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17b94628f56c1877b8998f921b14a5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#ab17b94628f56c1877b8998f921b14a5c">unpack</a> (<a class="el" href="classmsgpack_1_1object__handle.html">object_handle</a> &amp;result, const char *data, std::size_t len, std::size_t &amp;off, bool &amp;referenced, <a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a> f=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, void *user_data=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, <a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const  &amp;limit=<a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>())</td></tr>
<tr class="memdesc:ab17b94628f56c1877b8998f921b14a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer.  <a href="namespacemsgpack.html#ab17b94628f56c1877b8998f921b14a5c">More...</a><br /></td></tr>
<tr class="separator:ab17b94628f56c1877b8998f921b14a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e59a17ad832a676f40d26e2b77b901"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#ad9e59a17ad832a676f40d26e2b77b901">unpack</a> (<a class="el" href="classmsgpack_1_1object__handle.html">object_handle</a> &amp;result, const char *data, std::size_t len, std::size_t &amp;off, <a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a> f=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, void *user_data=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, <a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const  &amp;limit=<a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>())</td></tr>
<tr class="memdesc:ad9e59a17ad832a676f40d26e2b77b901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer.  <a href="namespacemsgpack.html#ad9e59a17ad832a676f40d26e2b77b901">More...</a><br /></td></tr>
<tr class="separator:ad9e59a17ad832a676f40d26e2b77b901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485484ea725c1356c74205fbcab3761e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a485484ea725c1356c74205fbcab3761e">unpack</a> (<a class="el" href="classmsgpack_1_1object__handle.html">object_handle</a> &amp;result, const char *data, std::size_t len, bool &amp;referenced, <a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a> f=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, void *user_data=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, <a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const  &amp;limit=<a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>())</td></tr>
<tr class="memdesc:a485484ea725c1356c74205fbcab3761e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer.  <a href="namespacemsgpack.html#a485484ea725c1356c74205fbcab3761e">More...</a><br /></td></tr>
<tr class="separator:a485484ea725c1356c74205fbcab3761e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0589c3a12a3d3ed3ed728368ff01de25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a0589c3a12a3d3ed3ed728368ff01de25">unpack</a> (<a class="el" href="classmsgpack_1_1object__handle.html">object_handle</a> &amp;result, const char *data, std::size_t len, <a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a> f=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, void *user_data=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, <a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const  &amp;limit=<a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>())</td></tr>
<tr class="memdesc:a0589c3a12a3d3ed3ed728368ff01de25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer.  <a href="namespacemsgpack.html#a0589c3a12a3d3ed3ed728368ff01de25">More...</a><br /></td></tr>
<tr class="separator:a0589c3a12a3d3ed3ed728368ff01de25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada094d8106707e53187f166b1d9b2ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#aada094d8106707e53187f166b1d9b2ec">unpack</a> (<a class="el" href="classmsgpack_1_1zone.html">msgpack::zone</a> &amp;z, const char *data, std::size_t len, std::size_t &amp;off, bool &amp;referenced, <a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a> f=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, void *user_data=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, <a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const  &amp;limit=<a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>())</td></tr>
<tr class="memdesc:aada094d8106707e53187f166b1d9b2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer.  <a href="namespacemsgpack.html#aada094d8106707e53187f166b1d9b2ec">More...</a><br /></td></tr>
<tr class="separator:aada094d8106707e53187f166b1d9b2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9c22d2cb66210b46f765c0c6318224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a4e9c22d2cb66210b46f765c0c6318224">unpack</a> (<a class="el" href="classmsgpack_1_1zone.html">msgpack::zone</a> &amp;z, const char *data, std::size_t len, std::size_t &amp;off, <a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a> f=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, void *user_data=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, <a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const  &amp;limit=<a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>())</td></tr>
<tr class="memdesc:a4e9c22d2cb66210b46f765c0c6318224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer.  <a href="namespacemsgpack.html#a4e9c22d2cb66210b46f765c0c6318224">More...</a><br /></td></tr>
<tr class="separator:a4e9c22d2cb66210b46f765c0c6318224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6c1909ed7a3fec77bc7c6c6f2ab2a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a2c6c1909ed7a3fec77bc7c6c6f2ab2a4">unpack</a> (<a class="el" href="classmsgpack_1_1zone.html">msgpack::zone</a> &amp;z, const char *data, std::size_t len, bool &amp;referenced, <a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a> f=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, void *user_data=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, <a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const  &amp;limit=<a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>())</td></tr>
<tr class="memdesc:a2c6c1909ed7a3fec77bc7c6c6f2ab2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer.  <a href="namespacemsgpack.html#a2c6c1909ed7a3fec77bc7c6c6f2ab2a4">More...</a><br /></td></tr>
<tr class="separator:a2c6c1909ed7a3fec77bc7c6c6f2ab2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba373f20c0690df9f6868fa790aafbf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#aba373f20c0690df9f6868fa790aafbf4">unpack</a> (<a class="el" href="classmsgpack_1_1zone.html">msgpack::zone</a> &amp;z, const char *data, std::size_t len, <a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a> f=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, void *user_data=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, <a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const  &amp;limit=<a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>())</td></tr>
<tr class="memdesc:aba373f20c0690df9f6868fa790aafbf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer.  <a href="namespacemsgpack.html#aba373f20c0690df9f6868fa790aafbf4">More...</a><br /></td></tr>
<tr class="separator:aba373f20c0690df9f6868fa790aafbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affeb052a27b2eece6e9b5426e50070f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#affeb052a27b2eece6e9b5426e50070f1">unpack</a> (<a class="el" href="classmsgpack_1_1object__handle.html">object_handle</a> *result, const char *data, std::size_t len, std::size_t *off=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, bool *referenced=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, <a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a> f=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, void *user_data=<a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, <a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const  &amp;limit=<a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>())</td></tr>
<tr class="memdesc:affeb052a27b2eece6e9b5426e50070f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer. [obsolete].  <a href="namespacemsgpack.html#affeb052a27b2eece6e9b5426e50070f1">More...</a><br /></td></tr>
<tr class="separator:affeb052a27b2eece6e9b5426e50070f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad844d148ad1ff6c9193b02529fe32968"><td class="memTemplParams" colspan="2">template&lt;typename Visitor &gt; </td></tr>
<tr class="memitem:ad844d148ad1ff6c9193b02529fe32968"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#ad844d148ad1ff6c9193b02529fe32968">parse</a> (const char *data, size_t len, size_t &amp;off, Visitor &amp;v)</td></tr>
<tr class="memdesc:ad844d148ad1ff6c9193b02529fe32968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack msgpack formatted data via a visitor.  <a href="namespacemsgpack.html#ad844d148ad1ff6c9193b02529fe32968">More...</a><br /></td></tr>
<tr class="separator:ad844d148ad1ff6c9193b02529fe32968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c644afb1b37d046c2d79a7622903468"><td class="memTemplParams" colspan="2">template&lt;typename Visitor &gt; </td></tr>
<tr class="memitem:a6c644afb1b37d046c2d79a7622903468"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a6c644afb1b37d046c2d79a7622903468">parse</a> (const char *data, size_t len, Visitor &amp;v)</td></tr>
<tr class="memdesc:a6c644afb1b37d046c2d79a7622903468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack msgpack formatted data via a visitor.  <a href="namespacemsgpack.html#a6c644afb1b37d046c2d79a7622903468">More...</a><br /></td></tr>
<tr class="separator:a6c644afb1b37d046c2d79a7622903468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79eb9f2bb5a7fe9b99624371b10b7248"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsgpack.html#a79eb9f2bb5a7fe9b99624371b10b7248">unpack</a> (<a class="el" href="classmsgpack_1_1object__handle.html">msgpack::object_handle</a> &amp;result, const char *data, std::size_t len, std::size_t &amp;off, msgpack::v3::unpack_reference_func f, void *user_data, <a class="el" href="classmsgpack_1_1unpack__limit.html">msgpack::unpack_limit</a> const &amp;limit)</td></tr>
<tr class="separator:a79eb9f2bb5a7fe9b99624371b10b7248"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a250cf933f89282ba40ed3fa0e61496b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250cf933f89282ba40ed3fa0e61496b6">&#9670;&nbsp;</a></span>all_of</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class T, class... U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemsgpack.html#a250cf933f89282ba40ed3fa0e61496b6">msgpack::all_of</a> = typedef <a class="el" href="structmsgpack_1_1detail_1_1all__of__imp.html">detail::all_of_imp</a>&lt;T&lt;U&gt;::value...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a710137be42540a5133f68416b82af064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710137be42540a5133f68416b82af064">&#9670;&nbsp;</a></span>any_of</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class T, class... U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemsgpack.html#a710137be42540a5133f68416b82af064">msgpack::any_of</a> = typedef <a class="el" href="structmsgpack_1_1detail_1_1any__of__imp.html">detail::any_of_imp</a>&lt;(T&lt;U&gt;::value)...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74841406f4ad1b1b1bf51d5290418697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74841406f4ad1b1b1bf51d5290418697">&#9670;&nbsp;</a></span>unpack_reference_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* msgpack::unpack_reference_func) (<a class="el" href="namespacemsgpack_1_1type.html#aebeb894b31101ddccf113e9ea8063543">msgpack::type::object_type</a> type, std::size_t size, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of reference or copy judging function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>msgpack data type. </td></tr>
    <tr><td class="paramname">size</td><td>msgpack data size. </td></tr>
    <tr><td class="paramname">user_data</td><td>The user_data that is set by <a class="el" href="namespacemsgpack.html#af8c675c74116393a0b90e4dc64d18a0d" title="Unpack msgpack::object from a buffer.">msgpack::unpack</a> functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the data should be referenced, then return true, otherwise (should be copied) false.</dd></dl>
<p>This function is called when unpacking STR, BIN, or EXT. </p>

</div>
</div>
<a id="a50ab177cb30e697ad240ade7d0f91ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ab177cb30e697ad240ade7d0f91ceb">&#9670;&nbsp;</a></span>unpacked</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classmsgpack_1_1object__handle.html">object_handle</a> <a class="el" href="namespacemsgpack.html#a50ab177cb30e697ad240ade7d0f91ceb">msgpack::unpacked</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ad2aa541d4168ec1c937a76b73f26020e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2aa541d4168ec1c937a76b73f26020e">&#9670;&nbsp;</a></span>parse_return <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020e">msgpack::parse_return</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad2aa541d4168ec1c937a76b73f26020ea34e4a2c3d4a4d61e3e005d770f9b1f3a"></a>PARSE_SUCCESS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2aa541d4168ec1c937a76b73f26020ea2d14189ec74ce05fa981495fa6fe638f"></a>PARSE_EXTRA_BYTES&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2aa541d4168ec1c937a76b73f26020ea11b259f07434bbdbfc0092e51d4b76b1"></a>PARSE_CONTINUE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2aa541d4168ec1c937a76b73f26020eae3afbf3256871bb72186fdfcbbaa5141"></a>PARSE_PARSE_ERROR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2aa541d4168ec1c937a76b73f26020ea34e4a2c3d4a4d61e3e005d770f9b1f3a"></a>PARSE_SUCCESS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2aa541d4168ec1c937a76b73f26020ea2d14189ec74ce05fa981495fa6fe638f"></a>PARSE_EXTRA_BYTES&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2aa541d4168ec1c937a76b73f26020ea11b259f07434bbdbfc0092e51d4b76b1"></a>PARSE_CONTINUE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2aa541d4168ec1c937a76b73f26020eae3afbf3256871bb72186fdfcbbaa5141"></a>PARSE_PARSE_ERROR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2aa541d4168ec1c937a76b73f26020ea33d5d29228314944dd990a35870aaf3f"></a>PARSE_STOP_VISITOR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad2aa541d4168ec1c937a76b73f26020e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2aa541d4168ec1c937a76b73f26020e">&#9670;&nbsp;</a></span>parse_return <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020e">msgpack::parse_return</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad2aa541d4168ec1c937a76b73f26020ea34e4a2c3d4a4d61e3e005d770f9b1f3a"></a>PARSE_SUCCESS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2aa541d4168ec1c937a76b73f26020ea2d14189ec74ce05fa981495fa6fe638f"></a>PARSE_EXTRA_BYTES&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2aa541d4168ec1c937a76b73f26020ea11b259f07434bbdbfc0092e51d4b76b1"></a>PARSE_CONTINUE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2aa541d4168ec1c937a76b73f26020eae3afbf3256871bb72186fdfcbbaa5141"></a>PARSE_PARSE_ERROR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2aa541d4168ec1c937a76b73f26020ea34e4a2c3d4a4d61e3e005d770f9b1f3a"></a>PARSE_SUCCESS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2aa541d4168ec1c937a76b73f26020ea2d14189ec74ce05fa981495fa6fe638f"></a>PARSE_EXTRA_BYTES&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2aa541d4168ec1c937a76b73f26020ea11b259f07434bbdbfc0092e51d4b76b1"></a>PARSE_CONTINUE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2aa541d4168ec1c937a76b73f26020eae3afbf3256871bb72186fdfcbbaa5141"></a>PARSE_PARSE_ERROR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2aa541d4168ec1c937a76b73f26020ea33d5d29228314944dd990a35870aaf3f"></a>PARSE_STOP_VISITOR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2d45dde870073a0e887745d2d2a36f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d45dde870073a0e887745d2d2a36f5e">&#9670;&nbsp;</a></span>aligned_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t msgpack::aligned_size </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespacemsgpack_1_1type.html#a7a061773204f4469948f1e39097da648">msgpack::type::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="structmsgpack_1_1aligned__zone__size__visitor.html#a657c435412ffccf83590d1dba3863a13">msgpack::aligned_zone_size_visitor::start_array()</a>, <a class="el" href="structmsgpack_1_1aligned__zone__size__visitor.html#a0eb484553f66849ec064a29558cfaae2">msgpack::aligned_zone_size_visitor::start_map()</a>, <a class="el" href="structmsgpack_1_1aligned__zone__size__visitor.html#a4fc8e9758a20f4b450bc9cefed7fc8da">msgpack::aligned_zone_size_visitor::visit_bin()</a>, <a class="el" href="structmsgpack_1_1aligned__zone__size__visitor.html#a21eddc1d74967fa8386e557e7653a44d">msgpack::aligned_zone_size_visitor::visit_ext()</a>, and <a class="el" href="structmsgpack_1_1aligned__zone__size__visitor.html#aa97e407d3932240d902c224e28919de0">msgpack::aligned_zone_size_visitor::visit_str()</a>.</p>

</div>
</div>
<a id="a68dd172d5ccb1d4acb6b6a8f3fc3e176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dd172d5ccb1d4acb6b6a8f3fc3e176">&#9670;&nbsp;</a></span>aligned_zone_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t msgpack::aligned_zone_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> const &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classmsgpack_1_1object__parser.html#a4b4ac74ed883feda2b0080b76ebe8685">msgpack::object_parser::parse()</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespacemsgpack.html#a5ecc1ef629295f23da063193cb92bd92">clone()</a>.</p>

</div>
</div>
<a id="aff8cffa75e7341c0b1a3fd305fe0899f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8cffa75e7341c0b1a3fd305fe0899f">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> * msgpack::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmsgpack_1_1object__array.html">msgpack::object_array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structmsgpack_1_1object__array.html#a4a6537f486fd57378be4417f95fd1482">msgpack::object_array::ptr</a>.</p>

</div>
</div>
<a id="a24b8e847a886a176e07d7196704460a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b8e847a886a176e07d7196704460a0">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmsgpack_1_1object__kv.html">msgpack::object_kv</a> * msgpack::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmsgpack_1_1object__map.html">msgpack::object_map</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structmsgpack_1_1object__map.html#adaf2cc60fd9552ad6686e6065ab04e84">msgpack::object_map::ptr</a>.</p>

</div>
</div>
<a id="aefe35d89e3cc78ab06526e501d8604d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe35d89e3cc78ab06526e501d8604d3">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> * msgpack::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsgpack_1_1object__array.html">msgpack::object_array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structmsgpack_1_1object__array.html#a4a6537f486fd57378be4417f95fd1482">msgpack::object_array::ptr</a>.</p>

</div>
</div>
<a id="ad52c02be11a42c58799707aa0b71ca4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52c02be11a42c58799707aa0b71ca4e">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmsgpack_1_1object__kv.html">msgpack::object_kv</a> * msgpack::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsgpack_1_1object__map.html">msgpack::object_map</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structmsgpack_1_1object__map.html#adaf2cc60fd9552ad6686e6065ab04e84">msgpack::object_map::ptr</a>.</p>

</div>
</div>
<a id="ac49d09a4923b1fe9a8951bec4ce19d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49d09a4923b1fe9a8951bec4ce19d62">&#9670;&nbsp;</a></span>checked_get_container_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t msgpack::checked_get_container_size </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespacemsgpack_1_1type.html#a7a061773204f4469948f1e39097da648">msgpack::type::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1object_3_01const_01char_01_5_01_4.html#abbb8db0bb76cb6708f33b91760a29f87">msgpack::adaptor::object&lt; const char * &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object_3_01char_0f_n_0e_4.html#a2cd859b60a139a9f3534ad41f070165a">msgpack::adaptor::object&lt; char[N]&gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object_3_01const_01char_0f_n_0e_4.html#a415169541f94c9bb16ab58ec897d60b9">msgpack::adaptor::object&lt; const char[N]&gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object_3_01std_1_1array_3_01char_00_01_n_01_4_01_4.html#ae05c9d8654becc65243fe6cdc13cd33c">msgpack::adaptor::object&lt; std::array&lt; char, N &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object_3_01std_1_1array_3_01unsigned_01char_00_01_n_01_4_01_4.html#af67c3253856313642f3fb841b2a2f601">msgpack::adaptor::object&lt; std::array&lt; unsigned char, N &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object_3_01std_1_1string_01_4.html#a087f2738642e91fc3661ce19cebd63af">msgpack::adaptor::object&lt; std::string &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object_3_01std_1_1vector_3_01char_00_01_alloc_01_4_01_4.html#a26abcf442ad2c61b72fbe6057ddf73d9">msgpack::adaptor::object&lt; std::vector&lt; char, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object_3_01std_1_1vector_3_01unsigned_01char_00_01_alloc_01_4_01_4.html#a684afde5738e1903020c7601819bf1c2">msgpack::adaptor::object&lt; std::vector&lt; unsigned char, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1as_3_01_t_00_01typename_01msgpack_1_1enable__if_3_01detail_1_1is__se8677279a22acf65edc4a5bba2b360aae.html#a1e6bcee85a69f7e6b5fede1b3f380d39">msgpack::adaptor::as&lt; T, typename msgpack::enable_if&lt; detail::is_seq_no_pair_no_tuple&lt; T &gt;::value &amp;&amp;boost::mpl::fold&lt; T, boost::mpl::bool_&lt; true &gt;, boost::mpl::if_&lt; boost::mpl::or_&lt; boost::mpl::_1, msgpack::has_as&lt; boost::mpl::_2 &gt; &gt;, boost::mpl::bool_&lt; true &gt;, boost::mpl::bool_&lt; false &gt; &gt; &gt;::type::value &gt;::type &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1convert_3_01_t_00_01typename_01msgpack_1_1enable__if_3_01detail_1_1i0891772f94ba58818ca358ef44ae9bda.html#a249eafac2cd300780833dc19c2f2aaef">msgpack::adaptor::convert&lt; T, typename msgpack::enable_if&lt; detail::is_seq_no_pair_no_tuple&lt; T &gt;::value &gt;::type &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01const_01char_01_5_01_4.html#ad42df2c3d13ef7647b6283eedcc72fc2">msgpack::adaptor::object_with_zone&lt; const char * &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01char_0f_n_0e_4.html#abcd833693d79a1d5820b10493d0c3b89">msgpack::adaptor::object_with_zone&lt; char[N]&gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01const_01char_0f_n_0e_4.html#ac0c21de310c9ba630089f89f2bab7e18">msgpack::adaptor::object_with_zone&lt; const char[N]&gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01msgpack_1_1type_1_1array__ref_3_01_t_01_4_01_4.html#aa39bd022eeb25424c4443a2add5e5272">msgpack::adaptor::object_with_zone&lt; msgpack::type::array_ref&lt; T &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01msgpack_1_1type_1_1array__ref_3_01_t_0f_n_0e_4_01_4.html#ac3cb55fbba35e528b87f9642f6efb0b1">msgpack::adaptor::object_with_zone&lt; msgpack::type::array_ref&lt; T[N]&gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1array_3_01char_00_01_n_01_4_01_4.html#a35ddac6e779c3e0976dc181a45dcacce">msgpack::adaptor::object_with_zone&lt; std::array&lt; char, N &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a2c3f38f427934a672f4efb4de9b77917">msgpack::adaptor::object_with_zone&lt; std::array&lt; T, N &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1array_3_01unsigned_01char_00_01_n_01_4_01_4.html#a7a308b083d94bcba18fec3497a7cb6c8">msgpack::adaptor::object_with_zone&lt; std::array&lt; unsigned char, N &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1deque_3_01_t_00_01_alloc_01_4_01_4.html#a540bfd7ae948509ca3d9fa755bbac790">msgpack::adaptor::object_with_zone&lt; std::deque&lt; T, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1forward__list_3_01_t_00_01_alloc_01_4_01_4.html#a16c820312183d61414762230ece625e5">msgpack::adaptor::object_with_zone&lt; std::forward_list&lt; T, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1list_3_01_t_00_01_alloc_01_4_01_4.html#a0c0ef7a0b3fd76c4a19cde7f2d08690a">msgpack::adaptor::object_with_zone&lt; std::list&lt; T, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1map_3_01_k_00_01_v_00_01_compare_00_01_alloc_01_4_01_4.html#a10c979c1db1d1cf43238aafcb390478c">msgpack::adaptor::object_with_zone&lt; std::map&lt; K, V, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1multimap_3_01_k_00_01_v_00_01_compare_00_01_alloc_01_4_01_4.html#a1546c775644b0154f77b67e1631ba95b">msgpack::adaptor::object_with_zone&lt; std::multimap&lt; K, V, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1multiset_3_01_t_00_01_compare_00_01_alloc_01_4_01_4.html#a1c83738b7acba3d9d344b79318667a66">msgpack::adaptor::object_with_zone&lt; std::multiset&lt; T, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1set_3_01_t_00_01_compare_00_01_alloc_01_4_01_4.html#a89712c4612269f72bae21c78f683ba7a">msgpack::adaptor::object_with_zone&lt; std::set&lt; T, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1string_01_4.html#adeb443c9c3167c55b0eb283b0c5bfd00">msgpack::adaptor::object_with_zone&lt; std::string &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1unordered__map_3_01_k_00_01_v_00_01_haefa10a0b7757ac692f561053fc666c79.html#a3c06471acba295f11701f5d8bc55bdd5">msgpack::adaptor::object_with_zone&lt; std::unordered_map&lt; K, V, Hash, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1unordered__multimap_3_01_k_00_01_v_00_cb0b6776fc0df41210818e5a3c9f15cb.html#ae02d0461d8b9f3239d6ae0bcee45f444">msgpack::adaptor::object_with_zone&lt; std::unordered_multimap&lt; K, V, Hash, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1unordered__multiset_3_01_key_00_01_has762fca96734b668de9078b4375e7fd47.html#a630613e5e828d7a8616178fca8b83f5f">msgpack::adaptor::object_with_zone&lt; std::unordered_multiset&lt; Key, Hash, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1unordered__set_3_01_key_00_01_hash_00_97fe9b6fbaec081fa918ae054f3fdb90.html#a198c828aa3495ade267b7ae5aa045269">msgpack::adaptor::object_with_zone&lt; std::unordered_set&lt; Key, Hash, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1vector_3_01bool_00_01_alloc_01_4_01_4.html#a7dabb494a53253617206b38d57198f7e">msgpack::adaptor::object_with_zone&lt; std::vector&lt; bool, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1vector_3_01char_00_01_alloc_01_4_01_4.html#af8e7e5eb8ad98a2ca259d173ef50861c">msgpack::adaptor::object_with_zone&lt; std::vector&lt; char, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1vector_3_01_t_00_01_alloc_01_4_01_4.html#a2c35a7058bd0870735c5eb7b1ba911b6">msgpack::adaptor::object_with_zone&lt; std::vector&lt; T, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1vector_3_01unsigned_01char_00_01_alloc_01_4_01_4.html#ad4e118e09af4c44e8f69912974507dc9">msgpack::adaptor::object_with_zone&lt; std::vector&lt; unsigned char, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1wstring_01_4.html#ad7182c24e5ab4ba4a4a35e3370ab8cfd">msgpack::adaptor::object_with_zone&lt; std::wstring &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01_t_00_01typename_01msgpack_1_1enable__if_3_0139c55f93282ade660a9e903c581e3b54.html#a71b578abc705d08a510ba77f6bca2ed9">msgpack::adaptor::object_with_zone&lt; T, typename msgpack::enable_if&lt; detail::is_seq_no_pair_no_tuple&lt; T &gt;::value &gt;::type &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01_t_0f_n_0e_4.html#aeb990de5ee74fd2067593a1e5d2042d1">msgpack::adaptor::object_with_zone&lt; T[N]&gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01type_1_1assoc__vector_3_01_k_00_01_v_00_01_compare_00_01_alloc_01_4_01_4.html#aacf68d80d9daa074526196bc953163cd">msgpack::adaptor::object_with_zone&lt; type::assoc_vector&lt; K, V, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01unsigned_01char_0f_n_0e_4.html#ab3020dd490b56d9291a8712d87ddc1be">msgpack::adaptor::object_with_zone&lt; unsigned char[N]&gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01const_01unsigned_01char_0f_n_0e_4.html#aa1c7efffb052254805b36593efac7f38">msgpack::adaptor::object_with_zone&lt; const unsigned char[N]&gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1tuple_3_01_args_8_8_8_01_4_01_4.html#a77e62ed7c145e7dcb7f0c641bf29a97a">msgpack::adaptor::object_with_zone&lt; std::tuple&lt; Args... &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01const_01char_01_5_01_4.html#a02bc32382f6429adeb0601d02e6f9528">msgpack::adaptor::pack&lt; const char * &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01char_0f_n_0e_4.html#a715d8cfb81abea8b073e7c559bba7d78">msgpack::adaptor::pack&lt; char[N]&gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01const_01char_0f_n_0e_4.html#a30799c0d4096016a240e0b1086435cff">msgpack::adaptor::pack&lt; const char[N]&gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1type_1_1array__ref_3_01_t_01_4_01_4.html#ac0c6261296138c5b282cfebb894c12a6">msgpack::adaptor::pack&lt; msgpack::type::array_ref&lt; T &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1type_1_1array__ref_3_01_t_0f_n_0e_4_01_4.html#a61f3f9c2d1ebf5338c4b4cf861c9a200">msgpack::adaptor::pack&lt; msgpack::type::array_ref&lt; T[N]&gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1array_3_01char_00_01_n_01_4_01_4.html#ab6e9455b2242b56976032e285db33178">msgpack::adaptor::pack&lt; std::array&lt; char, N &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#aaed28ee1f40525c2fb62e4dea99a2ba9">msgpack::adaptor::pack&lt; std::array&lt; T, N &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1array_3_01unsigned_01char_00_01_n_01_4_01_4.html#a76d3521abf19052649624cc6d425ef68">msgpack::adaptor::pack&lt; std::array&lt; unsigned char, N &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1deque_3_01_t_00_01_alloc_01_4_01_4.html#a0a93914e76cd402091c5f732157116a8">msgpack::adaptor::pack&lt; std::deque&lt; T, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1forward__list_3_01_t_00_01_alloc_01_4_01_4.html#ae5200c6ec7eed4e3c63be617faa47c45">msgpack::adaptor::pack&lt; std::forward_list&lt; T, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1list_3_01_t_00_01_alloc_01_4_01_4.html#af0bd9e17869940ce4e753cff57fb1f63">msgpack::adaptor::pack&lt; std::list&lt; T, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1map_3_01_k_00_01_v_00_01_compare_00_01_alloc_01_4_01_4.html#a5bf9567cb09f9f5753fc08875cd124e6">msgpack::adaptor::pack&lt; std::map&lt; K, V, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1multimap_3_01_k_00_01_v_00_01_compare_00_01_alloc_01_4_01_4.html#aad327a212fba934f8d718197219ac8bc">msgpack::adaptor::pack&lt; std::multimap&lt; K, V, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1multiset_3_01_t_00_01_compare_00_01_alloc_01_4_01_4.html#a8d3a2b11b69238874d3edd568b675737">msgpack::adaptor::pack&lt; std::multiset&lt; T, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1set_3_01_t_00_01_compare_00_01_alloc_01_4_01_4.html#a02647e8fa7fa2320a7c4735d1aa9376b">msgpack::adaptor::pack&lt; std::set&lt; T, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1string_01_4.html#ae1c64a4eed61411854616c9eb9e16896">msgpack::adaptor::pack&lt; std::string &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1tuple_3_01_args_8_8_8_01_4_01_4.html#a8707044e90d2a9822af77b28d79dc3ee">msgpack::adaptor::pack&lt; std::tuple&lt; Args... &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1unordered__map_3_01_k_00_01_v_00_01_hash_00_01_compare_00_01_alloc_01_4_01_4.html#a7180181ab0b2a6b5d41f91c3f23bacfd">msgpack::adaptor::pack&lt; std::unordered_map&lt; K, V, Hash, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1unordered__multimap_3_01_k_00_01_v_00_01_hash_00_01_compare_00_01_alloc_01_4_01_4.html#a615ef2afe35a3004eac5ffc6830df0f9">msgpack::adaptor::pack&lt; std::unordered_multimap&lt; K, V, Hash, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1unordered__multiset_3_01_key_00_01_hash_00_01_compare_00_01_alloc_01_4_01_4.html#ae2120530ec4d23e1a062c7b00045a221">msgpack::adaptor::pack&lt; std::unordered_multiset&lt; Key, Hash, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1unordered__set_3_01_key_00_01_hash_00_01_compare_00_01_alloc_01_4_01_4.html#a976c3eddac8bf26b827d4f2cc03fef29">msgpack::adaptor::pack&lt; std::unordered_set&lt; Key, Hash, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1vector_3_01bool_00_01_alloc_01_4_01_4.html#a84ba397735da8f5e8eae2ef5d8e34b88">msgpack::adaptor::pack&lt; std::vector&lt; bool, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1vector_3_01char_00_01_alloc_01_4_01_4.html#a508a6967aba8c99eeb7cb513c213e943">msgpack::adaptor::pack&lt; std::vector&lt; char, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1vector_3_01_t_00_01_alloc_01_4_01_4.html#aa5765528a877b849974758aa7d168848">msgpack::adaptor::pack&lt; std::vector&lt; T, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1vector_3_01unsigned_01char_00_01_alloc_01_4_01_4.html#a86fda6de4bf4d536297d046138a6521a">msgpack::adaptor::pack&lt; std::vector&lt; unsigned char, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1wstring_01_4.html#a77e6b12170375d5a7d7f644827d785a7">msgpack::adaptor::pack&lt; std::wstring &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01_t_00_01typename_01msgpack_1_1enable__if_3_01detail_1_1is__074856029c005deceeb80753e84de4e9.html#a660371b85266369e571c2069d7602ff6">msgpack::adaptor::pack&lt; T, typename msgpack::enable_if&lt; detail::is_seq_no_pair_no_tuple&lt; T &gt;::value &gt;::type &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01_t_0f_n_0e_4.html#aa9c9714ec2d7e4bf68477fcdcd07cf28">msgpack::adaptor::pack&lt; T[N]&gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01type_1_1assoc__vector_3_01_k_00_01_v_00_01_compare_00_01_alloc_01_4_01_4.html#af7da3a9b183c9f1d2cd4f5ca7b802c0e">msgpack::adaptor::pack&lt; type::assoc_vector&lt; K, V, Compare, Alloc &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01unsigned_01char_0f_n_0e_4.html#a20aed5f75ec6333ab4236a7afbf90f5c">msgpack::adaptor::pack&lt; unsigned char[N]&gt;::operator()()</a>, and <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01const_01unsigned_01char_0f_n_0e_4.html#a2932a8c506a6cf21a03399a0686ac33a">msgpack::adaptor::pack&lt; const unsigned char[N]&gt;::operator()()</a>.</p>

</div>
</div>
<a id="a5ecc1ef629295f23da063193cb92bd92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ecc1ef629295f23da063193cb92bd92">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1object__handle.html">object_handle</a> msgpack::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> const &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>clone object </p>
<p>Clone (deep copy) object. The copied object is located on newly allocated zone. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>copy source object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmsgpack_1_1object__handle.html" title="The class holds object and zone.">object_handle</a> that holds deep copied object and zone. </dd></dl>

<p class="reference">References <a class="el" href="namespacemsgpack.html#a68dd172d5ccb1d4acb6b6a8f3fc3e176">aligned_zone_size()</a>, <a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a>, and <a class="el" href="namespacemsgpack_1_1type.html#a7a061773204f4469948f1e39097da648">msgpack::type::size()</a>.</p>

</div>
</div>
<a id="ad791b12166312c367396778baf52e949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad791b12166312c367396778baf52e949">&#9670;&nbsp;</a></span>convert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void msgpack::convert </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> const &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structmsgpack_1_1object.html#a966586675f3c41ba3eeee3424e77e7ac">msgpack::object::convert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="structmsgpack_1_1object.html#a759bd99973bc67996633b6fb5bd9096a">msgpack::object::convert()</a>, <a class="el" href="namespacemsgpack_1_1type_1_1detail.html#a809ff068b3d3f9d6da23e9c4d07fac64">msgpack::type::detail::convert_integer()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1convert_3_01msgpack_1_1type_1_1tuple_3_01_args_8_8_8_01_4_01_4.html#aba15446dfb2d7eda1a605b96670c23fc">msgpack::adaptor::convert&lt; msgpack::type::tuple&lt; Args... &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1convert_3_01std_1_1tuple_3_01_args_8_8_8_01_4_01_4.html#a18d9e2f221d3110cbb637bfde67cf5d4">msgpack::adaptor::convert&lt; std::tuple&lt; Args... &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01msgpack_1_1type_1_1tuple_3_01_args_8_8_8_01_4_01_4.html#a1ad601949fa799f7a7db340866e11a15">msgpack::adaptor::object_with_zone&lt; msgpack::type::tuple&lt; Args... &gt; &gt;::operator()()</a>, and <a class="el" href="structmsgpack_1_1adaptor_1_1object__with__zone_3_01std_1_1tuple_3_01_args_8_8_8_01_4_01_4.html#a77e62ed7c145e7dcb7f0c641bf29a97a">msgpack::adaptor::object_with_zone&lt; std::tuple&lt; Args... &gt; &gt;::operator()()</a>.</p>

</div>
</div>
<a id="aa730ad9ebd655c74ec9dc2dc6f63830b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa730ad9ebd655c74ec9dc2dc6f63830b">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> * msgpack::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmsgpack_1_1object__array.html">msgpack::object_array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structmsgpack_1_1object__array.html#a4a6537f486fd57378be4417f95fd1482">msgpack::object_array::ptr</a>, and <a class="el" href="structmsgpack_1_1object__array.html#a15e7a07017a5fa7018c466a24634ec68">msgpack::object_array::size</a>.</p>

</div>
</div>
<a id="aa30d076b7c0675b902871d3784e6cfad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30d076b7c0675b902871d3784e6cfad">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structmsgpack_1_1object__kv.html">msgpack::object_kv</a> * msgpack::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmsgpack_1_1object__map.html">msgpack::object_map</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structmsgpack_1_1object__map.html#adaf2cc60fd9552ad6686e6065ab04e84">msgpack::object_map::ptr</a>, and <a class="el" href="structmsgpack_1_1object__map.html#a5050f181f092c4f6f22b27d4cdc17289">msgpack::object_map::size</a>.</p>

</div>
</div>
<a id="a19d68932a92c29b8bbb18e2ce0f78f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d68932a92c29b8bbb18e2ce0f78f65">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> * msgpack::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsgpack_1_1object__array.html">msgpack::object_array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structmsgpack_1_1object__array.html#a4a6537f486fd57378be4417f95fd1482">msgpack::object_array::ptr</a>, and <a class="el" href="structmsgpack_1_1object__array.html#a15e7a07017a5fa7018c466a24634ec68">msgpack::object_array::size</a>.</p>

</div>
</div>
<a id="a9426a4160106ee0a2574c731656ea9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9426a4160106ee0a2574c731656ea9ac">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmsgpack_1_1object__kv.html">msgpack::object_kv</a> * msgpack::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsgpack_1_1object__map.html">msgpack::object_map</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structmsgpack_1_1object__map.html#adaf2cc60fd9552ad6686e6065ab04e84">msgpack::object_map::ptr</a>, and <a class="el" href="structmsgpack_1_1object__map.html#a5050f181f092c4f6f22b27d4cdc17289">msgpack::object_map::size</a>.</p>

<p class="reference">Referenced by <a class="el" href="structmsgpack_1_1adaptor_1_1convert_3_01std_1_1vector_3_01bool_00_01_alloc_01_4_01_4.html#aa20a282e1a711e6210f0793550e3db40">msgpack::adaptor::convert&lt; std::vector&lt; bool, Alloc &gt; &gt;::operator()()</a>.</p>

</div>
</div>
<a id="aec3a2a617c1c1ecf19f72f0bfe93b20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3a2a617c1c1ecf19f72f0bfe93b20b">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool msgpack::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96378a28e48ee7da1c3a4fba31dcab08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96378a28e48ee7da1c3a4fba31dcab08">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool msgpack::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3ed2ffbc19708522cef93ebf91840e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ed2ffbc19708522cef93ebf91840e5">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool msgpack::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c5b31bf2abe509e59041696de091dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5b31bf2abe509e59041696de091dd4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void msgpack::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>v</em>[N]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b90e1ea7d84b530687b8b933eec8c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b90e1ea7d84b530687b8b933eec8c74">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">msgpack::enable_if&lt; !is_array&lt; T &gt;::value &gt;::type msgpack::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a59cc917bec1e9289d3d6da0b09d8c9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59cc917bec1e9289d3d6da0b09d8c9a7">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void msgpack::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsgpack_1_1object_1_1with__zone.html">msgpack::object::with_zone</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>v</em>[N]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="accacd7e7e5a196fb3452a8a744e14213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accacd7e7e5a196fb3452a8a744e14213">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">msgpack::enable_if&lt; !is_array&lt; T &gt;::value &gt;::type msgpack::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsgpack_1_1object_1_1with__zone.html">msgpack::object::with_zone</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f36b156764461cc87047ca6f8997c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f36b156764461cc87047ca6f8997c69">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp; msgpack::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespacemsgpack.html#a129e066299f13283fbf9b35233ca4274">pack()</a>.</p>

</div>
</div>
<a id="acc80c71db083a277afd0f414ccb0d5da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc80c71db083a277afd0f414ccb0d5da">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp; msgpack::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmsgpack_1_1object_1_1with__zone.html">msgpack::object::with_zone</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8455b5642bac84788998304025d78e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8455b5642bac84788998304025d78e0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp; msgpack::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>v</em>[N]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4201954718c3c9a46a208e429ef5b359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4201954718c3c9a46a208e429ef5b359">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">msgpack::enable_if&lt; !is_array&lt; T &gt;::value, <a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp; &gt;::type msgpack::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="structmsgpack_1_1object.html#ae7089d66fbd7b29a547e07d9ed1aee9f">msgpack::object::object()</a>, and <a class="el" href="classmsgpack_1_1packer.html#ae787682cb2fa52186ed788b3e0103d1c">msgpack::packer&lt; Stream &gt;::pack()</a>.</p>

</div>
</div>
<a id="a9df79ce87fe26fffeecd5bdc41ce7f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df79ce87fe26fffeecd5bdc41ce7f00">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void msgpack::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">msgpack::v1::object &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>v</em>[N]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9edd3e6cd417d3ba840890481235f758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9edd3e6cd417d3ba840890481235f758">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; msgpack::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classmsgpack_1_1object__parser.html#a4b4ac74ed883feda2b0080b76ebe8685">msgpack::object_parser::parse()</a>.</p>

</div>
</div>
<a id="a1d7bc570680b8ae0de1c749c8e2613a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7bc570680b8ae0de1c749c8e2613a3">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool msgpack::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classmsgpack_1_1object__parser.html#a4b4ac74ed883feda2b0080b76ebe8685">msgpack::object_parser::parse()</a>, and <a class="el" href="structmsgpack_1_1object.html#aa0485f12b0839f0341249b8e28595fc9">msgpack::object::type</a>.</p>

</div>
</div>
<a id="accbcb500a7141081366c29fe0b981911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbcb500a7141081366c29fe0b981911">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool msgpack::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a915eca1267162ec5c2f83a77760272cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915eca1267162ec5c2f83a77760272cd">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool msgpack::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aec73610d06debb4a9921afecf13b4586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec73610d06debb4a9921afecf13b4586">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">msgpack::enable_if&lt; !is_array&lt; T &gt;::value, <a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> const  &amp; &gt;::type msgpack::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> const &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="structmsgpack_1_1object.html#a966586675f3c41ba3eeee3424e77e7ac">msgpack::object::convert()</a>, and <a class="el" href="classmsgpack_1_1define.html#ae414ae8ad8a7d4b3084aca0e5abdf70c">msgpack::define&lt; Type &gt;::msgpack_unpack()</a>.</p>

</div>
</div>
<a id="abb1f207df87c6130921599a44aadeee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1f207df87c6130921599a44aadeee7">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> const  &amp; msgpack::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> const &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>v</em>[N]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a129e066299f13283fbf9b35233ca4274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129e066299f13283fbf9b35233ca4274">&#9670;&nbsp;</a></span>pack() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void msgpack::pack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classmsgpack_1_1packer.html#ad936992e4324e8a5a31d53745fef7e09">msgpack::packer&lt; Stream &gt;::pack()</a>.</p>

<p class="reference">Referenced by <a class="el" href="structmsgpack_1_1type_1_1define__array.html#a4f3c1c8af04f5246ee81f7ff1e04fa2c">msgpack::type::define_array&lt; Args &gt;::msgpack_pack()</a>, <a class="el" href="structmsgpack_1_1type_1_1define__map.html#a308215020bf0a20a35943697a3c2d35c">msgpack::type::define_map&lt; Args &gt;::msgpack_pack()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01msgpack_1_1type_1_1tuple_3_01_args_8_8_8_01_4_01_4.html#a56c23f346e2b6e6ac6a46265e3705bdc">msgpack::adaptor::pack&lt; msgpack::type::tuple&lt; Args... &gt; &gt;::operator()()</a>, <a class="el" href="structmsgpack_1_1adaptor_1_1pack_3_01std_1_1tuple_3_01_args_8_8_8_01_4_01_4.html#a8707044e90d2a9822af77b28d79dc3ee">msgpack::adaptor::pack&lt; std::tuple&lt; Args... &gt; &gt;::operator()()</a>, and <a class="el" href="namespacemsgpack.html#a6f36b156764461cc87047ca6f8997c69">operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="afb0d5514b0618ebde91469fa148e5813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0d5514b0618ebde91469fa148e5813">&#9670;&nbsp;</a></span>pack() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void msgpack::pack </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack the value as MessagePack format into the stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stream</td><td>Any type that have a member function <code>Stream write(const char*, size_t s)</code> </td></tr>
    <tr><td class="paramname">T</td><td>Any type that is adapted to MessagePack </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Packing destination stream </td></tr>
    <tr><td class="paramname">v</td><td>Packing value </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classmsgpack_1_1packer.html#ad936992e4324e8a5a31d53745fef7e09">msgpack::packer&lt; Stream &gt;::pack()</a>.</p>

</div>
</div>
<a id="a3a643bd4bc6e81ddf0bdd3ab79402eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a643bd4bc6e81ddf0bdd3ab79402eb5">&#9670;&nbsp;</a></span>pack() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void msgpack::pack </td>
          <td>(</td>
          <td class="paramtype">Stream *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack the value as MessagePack format into the stream. </p>
<p>This function template is left for compatibility. Use <code>void <a class="el" href="namespacemsgpack.html#afb0d5514b0618ebde91469fa148e5813" title="Pack the value as MessagePack format into the stream.">pack(Stream&amp; s, const T&amp; v)</a></code> instead of the function template.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stream</td><td>Any type that have a member function <code>Stream write(const char*, size_t s)</code> </td></tr>
    <tr><td class="paramname">T</td><td>Any type that is adapted to MessagePack </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The pointer to packing destination stream </td></tr>
    <tr><td class="paramname">v</td><td>Packing value </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classmsgpack_1_1packer.html#ad936992e4324e8a5a31d53745fef7e09">msgpack::packer&lt; Stream &gt;::pack()</a>.</p>

</div>
</div>
<a id="a43d65643344f10d9075dec8981ede689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d65643344f10d9075dec8981ede689">&#9670;&nbsp;</a></span>pack_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void msgpack::pack_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1packer.html">msgpack::packer</a>&lt; Stream &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad844d148ad1ff6c9193b02529fe32968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad844d148ad1ff6c9193b02529fe32968">&#9670;&nbsp;</a></span>parse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Visitor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool msgpack::parse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Visitor &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpack msgpack formatted data via a visitor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the buffer. </td></tr>
    <tr><td class="paramname">off</td><td>The offset position of the buffer. It is read and overwritten. </td></tr>
    <tr><td class="paramname">v</td><td>The visitor that satisfies visitor concept. <a href="https://github.com/msgpack/msgpack-c/wiki/v2_0_cpp_visitor#visitor-concept">https://github.com/msgpack/msgpack-c/wiki/v2_0_cpp_visitor#visitor-concept</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if unpacking process finishes without error then return true, otherwise return false. </dd></dl>

</div>
</div>
<a id="a6c644afb1b37d046c2d79a7622903468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c644afb1b37d046c2d79a7622903468">&#9670;&nbsp;</a></span>parse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Visitor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool msgpack::parse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Visitor &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpack msgpack formatted data via a visitor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the buffer. </td></tr>
    <tr><td class="paramname">v</td><td>The visitor that satisfies visitor concept. <a href="https://github.com/msgpack/msgpack-c/wiki/v2_0_cpp_visitor#visitor-concept">https://github.com/msgpack/msgpack-c/wiki/v2_0_cpp_visitor#visitor-concept</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if unpacking process finishes without error then return true, otherwise return false. </dd></dl>

</div>
</div>
<a id="a104c8fefce26163d0b7f6467088d6a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104c8fefce26163d0b7f6467088d6a98">&#9670;&nbsp;</a></span>unpack() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1object__handle.html">msgpack::object_handle</a> msgpack::unpack </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>referenced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a>&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const &amp;&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the buffer. </td></tr>
    <tr><td class="paramname">referenced</td><td>If the unpacked object contains reference of the buffer, then set as true, otherwise false. </td></tr>
    <tr><td class="paramname">f</td><td>A judging function that <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> refer to the buffer. </td></tr>
    <tr><td class="paramname">user_data</td><td>This parameter is passed to f. </td></tr>
    <tr><td class="paramname">limit</td><td>The size limit information of <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmsgpack_1_1object__handle.html" title="The class holds object and zone.">object_handle</a> that contains unpacked data. </dd></dl>

<p class="reference">References <a class="el" href="namespacemsgpack.html#af8c675c74116393a0b90e4dc64d18a0d">unpack()</a>.</p>

</div>
</div>
<a id="af8c675c74116393a0b90e4dc64d18a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c675c74116393a0b90e4dc64d18a0d">&#9670;&nbsp;</a></span>unpack() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1object__handle.html">msgpack::object_handle</a> msgpack::unpack </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>referenced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a>&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const &amp;&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the buffer. </td></tr>
    <tr><td class="paramname">off</td><td>The offset position of the buffer. It is read and overwritten. </td></tr>
    <tr><td class="paramname">referenced</td><td>If the unpacked object contains reference of the buffer, then set as true, otherwise false. </td></tr>
    <tr><td class="paramname">f</td><td>A judging function that <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> refer to the buffer. </td></tr>
    <tr><td class="paramname">user_data</td><td>This parameter is passed to f. </td></tr>
    <tr><td class="paramname">limit</td><td>The size limit information of <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmsgpack_1_1object__handle.html" title="The class holds object and zone.">object_handle</a> that contains unpacked data. </dd></dl>

<p class="reference">References <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea11b259f07434bbdbfc0092e51d4b76b1">PARSE_CONTINUE</a>, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea2d14189ec74ce05fa981495fa6fe638f">PARSE_EXTRA_BYTES</a>, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020eae3afbf3256871bb72186fdfcbbaa5141">PARSE_PARSE_ERROR</a>, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea34e4a2c3d4a4d61e3e005d770f9b1f3a">PARSE_SUCCESS</a>, and <a class="el" href="namespacemsgpack_1_1detail.html#a53b09020df222a85f50b415c705833c9">msgpack::detail::unpack_imp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="structmsgpack_1_1type_1_1define__array.html#aa7bd0d64f934985068d190c48be48cf0">msgpack::type::define_array&lt; Args &gt;::msgpack_unpack()</a>, <a class="el" href="structmsgpack_1_1type_1_1define__map.html#a0d19bd0fe04220d333d269977944ce69">msgpack::type::define_map&lt; Args &gt;::msgpack_unpack()</a>, and <a class="el" href="namespacemsgpack.html#a49d86345e00d1f7a201a534163644981">unpack()</a>.</p>

</div>
</div>
<a id="a49d86345e00d1f7a201a534163644981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d86345e00d1f7a201a534163644981">&#9670;&nbsp;</a></span>unpack() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1object__handle.html">msgpack::object_handle</a> msgpack::unpack </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a>&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const &amp;&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the buffer. </td></tr>
    <tr><td class="paramname">off</td><td>The offset position of the buffer. It is read and overwritten. </td></tr>
    <tr><td class="paramname">f</td><td>A judging function that <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> refer to the buffer. </td></tr>
    <tr><td class="paramname">user_data</td><td>This parameter is passed to f. </td></tr>
    <tr><td class="paramname">limit</td><td>The size limit information of <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmsgpack_1_1object__handle.html" title="The class holds object and zone.">object_handle</a> that contains unpacked data. </dd></dl>

<p class="reference">References <a class="el" href="namespacemsgpack.html#af8c675c74116393a0b90e4dc64d18a0d">unpack()</a>.</p>

</div>
</div>
<a id="a21d60c5f750195ba8ed8cab7ceab3ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d60c5f750195ba8ed8cab7ceab3ca6">&#9670;&nbsp;</a></span>unpack() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmsgpack_1_1object__handle.html">msgpack::object_handle</a> msgpack::unpack </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a>&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const &amp;&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the buffer. </td></tr>
    <tr><td class="paramname">f</td><td>A judging function that <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> refer to the buffer. </td></tr>
    <tr><td class="paramname">user_data</td><td>This parameter is passed to f. </td></tr>
    <tr><td class="paramname">limit</td><td>The size limit information of <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmsgpack_1_1object__handle.html" title="The class holds object and zone.">object_handle</a> that contains unpacked data. </dd></dl>

<p class="reference">References <a class="el" href="namespacemsgpack.html#af8c675c74116393a0b90e4dc64d18a0d">unpack()</a>.</p>

</div>
</div>
<a id="a79eb9f2bb5a7fe9b99624371b10b7248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79eb9f2bb5a7fe9b99624371b10b7248">&#9670;&nbsp;</a></span>unpack() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void msgpack::unpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1object__handle.html">msgpack::object_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">msgpack::v3::unpack_reference_func&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1unpack__limit.html">msgpack::unpack_limit</a> const &amp;&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c6c1909ed7a3fec77bc7c6c6f2ab2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6c1909ed7a3fec77bc7c6c6f2ab2a4">&#9670;&nbsp;</a></span>unpack() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> msgpack::unpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1zone.html">msgpack::zone</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>referenced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a>&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const &amp;&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>The <a class="el" href="classmsgpack_1_1zone.html">msgpack::zone</a> that is used as a memory of unpacked msgpack objects. </td></tr>
    <tr><td class="paramname">data</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the buffer. </td></tr>
    <tr><td class="paramname">referenced</td><td>If the unpacked object contains reference of the buffer, then set as true, otherwise false. </td></tr>
    <tr><td class="paramname">f</td><td>A judging function that <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> refer to the buffer. </td></tr>
    <tr><td class="paramname">user_data</td><td>This parameter is passed to f. </td></tr>
    <tr><td class="paramname">limit</td><td>The size limit information of <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> that contains unpacked data. </dd></dl>

<p class="reference">References <a class="el" href="namespacemsgpack.html#af8c675c74116393a0b90e4dc64d18a0d">unpack()</a>.</p>

</div>
</div>
<a id="aada094d8106707e53187f166b1d9b2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada094d8106707e53187f166b1d9b2ec">&#9670;&nbsp;</a></span>unpack() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> msgpack::unpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1zone.html">msgpack::zone</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>referenced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a>&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const &amp;&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>The <a class="el" href="classmsgpack_1_1zone.html">msgpack::zone</a> that is used as a memory of unpacked msgpack objects. </td></tr>
    <tr><td class="paramname">data</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the buffer. </td></tr>
    <tr><td class="paramname">off</td><td>The offset position of the buffer. It is read and overwritten. </td></tr>
    <tr><td class="paramname">referenced</td><td>If the unpacked object contains reference of the buffer, then set as true, otherwise false. </td></tr>
    <tr><td class="paramname">f</td><td>A judging function that <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> refer to the buffer. </td></tr>
    <tr><td class="paramname">user_data</td><td>This parameter is passed to f. </td></tr>
    <tr><td class="paramname">limit</td><td>The size limit information of <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> that contains unpacked data. </dd></dl>

<p class="reference">References <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea11b259f07434bbdbfc0092e51d4b76b1">PARSE_CONTINUE</a>, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea2d14189ec74ce05fa981495fa6fe638f">PARSE_EXTRA_BYTES</a>, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020eae3afbf3256871bb72186fdfcbbaa5141">PARSE_PARSE_ERROR</a>, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea34e4a2c3d4a4d61e3e005d770f9b1f3a">PARSE_SUCCESS</a>, and <a class="el" href="namespacemsgpack_1_1detail.html#a53b09020df222a85f50b415c705833c9">msgpack::detail::unpack_imp()</a>.</p>

</div>
</div>
<a id="a4e9c22d2cb66210b46f765c0c6318224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9c22d2cb66210b46f765c0c6318224">&#9670;&nbsp;</a></span>unpack() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> msgpack::unpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1zone.html">msgpack::zone</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a>&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const &amp;&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>The <a class="el" href="classmsgpack_1_1zone.html">msgpack::zone</a> that is used as a memory of unpacked msgpack objects. </td></tr>
    <tr><td class="paramname">data</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the buffer. </td></tr>
    <tr><td class="paramname">off</td><td>The offset position of the buffer. It is read and overwritten. </td></tr>
    <tr><td class="paramname">f</td><td>A judging function that <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> refer to the buffer. </td></tr>
    <tr><td class="paramname">user_data</td><td>This parameter is passed to f. </td></tr>
    <tr><td class="paramname">limit</td><td>The size limit information of <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> that contains unpacked data. </dd></dl>

<p class="reference">References <a class="el" href="namespacemsgpack.html#af8c675c74116393a0b90e4dc64d18a0d">unpack()</a>.</p>

</div>
</div>
<a id="aba373f20c0690df9f6868fa790aafbf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba373f20c0690df9f6868fa790aafbf4">&#9670;&nbsp;</a></span>unpack() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmsgpack_1_1object.html">msgpack::object</a> msgpack::unpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1zone.html">msgpack::zone</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a>&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const &amp;&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>The <a class="el" href="classmsgpack_1_1zone.html">msgpack::zone</a> that is used as a memory of unpacked msgpack objects. </td></tr>
    <tr><td class="paramname">data</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the buffer. </td></tr>
    <tr><td class="paramname">f</td><td>A judging function that <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> refer to the buffer. </td></tr>
    <tr><td class="paramname">user_data</td><td>This parameter is passed to f. </td></tr>
    <tr><td class="paramname">limit</td><td>The size limit information of <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> that contains unpacked data. </dd></dl>

<p class="reference">References <a class="el" href="namespacemsgpack.html#af8c675c74116393a0b90e4dc64d18a0d">unpack()</a>.</p>

</div>
</div>
<a id="a485484ea725c1356c74205fbcab3761e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485484ea725c1356c74205fbcab3761e">&#9670;&nbsp;</a></span>unpack() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void msgpack::unpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1object__handle.html">object_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>referenced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a>&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const &amp;&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The <a class="el" href="classmsgpack_1_1object__handle.html" title="The class holds object and zone.">object_handle</a> that contains unpacked data. </td></tr>
    <tr><td class="paramname">data</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the buffer. </td></tr>
    <tr><td class="paramname">referenced</td><td>If the unpacked object contains reference of the buffer, then set as true, otherwise false. </td></tr>
    <tr><td class="paramname">f</td><td>A judging function that <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> refer to the buffer. </td></tr>
    <tr><td class="paramname">user_data</td><td>This parameter is passed to f. </td></tr>
    <tr><td class="paramname">limit</td><td>The size limit information of <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacemsgpack.html#af8c675c74116393a0b90e4dc64d18a0d">unpack()</a>.</p>

</div>
</div>
<a id="ab17b94628f56c1877b8998f921b14a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17b94628f56c1877b8998f921b14a5c">&#9670;&nbsp;</a></span>unpack() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void msgpack::unpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1object__handle.html">object_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>referenced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a>&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const &amp;&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The <a class="el" href="classmsgpack_1_1object__handle.html" title="The class holds object and zone.">object_handle</a> that contains unpacked data. </td></tr>
    <tr><td class="paramname">data</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the buffer. </td></tr>
    <tr><td class="paramname">off</td><td>The offset position of the buffer. It is read and overwritten. </td></tr>
    <tr><td class="paramname">referenced</td><td>If the unpacked object contains reference of the buffer, then set as true, otherwise false. </td></tr>
    <tr><td class="paramname">f</td><td>A judging function that <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> refer to the buffer. </td></tr>
    <tr><td class="paramname">user_data</td><td>This parameter is passed to f. </td></tr>
    <tr><td class="paramname">limit</td><td>The size limit information of <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea11b259f07434bbdbfc0092e51d4b76b1">PARSE_CONTINUE</a>, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea2d14189ec74ce05fa981495fa6fe638f">PARSE_EXTRA_BYTES</a>, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020eae3afbf3256871bb72186fdfcbbaa5141">PARSE_PARSE_ERROR</a>, <a class="el" href="namespacemsgpack.html#ad2aa541d4168ec1c937a76b73f26020ea34e4a2c3d4a4d61e3e005d770f9b1f3a">PARSE_SUCCESS</a>, <a class="el" href="classmsgpack_1_1object__handle.html#aadf3cdc152b8463a2aa0b5af728d3454">msgpack::object_handle::set()</a>, <a class="el" href="namespacemsgpack_1_1detail.html#a53b09020df222a85f50b415c705833c9">msgpack::detail::unpack_imp()</a>, and <a class="el" href="classmsgpack_1_1object__handle.html#a96356fdba1681dd1e0f31404e5e75687">msgpack::object_handle::zone()</a>.</p>

</div>
</div>
<a id="ad9e59a17ad832a676f40d26e2b77b901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e59a17ad832a676f40d26e2b77b901">&#9670;&nbsp;</a></span>unpack() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void msgpack::unpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1object__handle.html">object_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a>&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const &amp;&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The <a class="el" href="classmsgpack_1_1object__handle.html" title="The class holds object and zone.">object_handle</a> that contains unpacked data. </td></tr>
    <tr><td class="paramname">data</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the buffer. </td></tr>
    <tr><td class="paramname">off</td><td>The offset position of the buffer. It is read and overwritten. </td></tr>
    <tr><td class="paramname">f</td><td>A judging function that <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> refer to the buffer. </td></tr>
    <tr><td class="paramname">user_data</td><td>This parameter is passed to f. </td></tr>
    <tr><td class="paramname">limit</td><td>The size limit information of <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacemsgpack.html#af8c675c74116393a0b90e4dc64d18a0d">unpack()</a>.</p>

</div>
</div>
<a id="a0589c3a12a3d3ed3ed728368ff01de25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0589c3a12a3d3ed3ed728368ff01de25">&#9670;&nbsp;</a></span>unpack() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void msgpack::unpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1object__handle.html">object_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a>&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const &amp;&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The <a class="el" href="classmsgpack_1_1object__handle.html" title="The class holds object and zone.">object_handle</a> that contains unpacked data. </td></tr>
    <tr><td class="paramname">data</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the buffer. </td></tr>
    <tr><td class="paramname">f</td><td>A judging function that <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> refer to the buffer. </td></tr>
    <tr><td class="paramname">user_data</td><td>This parameter is passed to f. </td></tr>
    <tr><td class="paramname">limit</td><td>The size limit information of <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacemsgpack.html#af8c675c74116393a0b90e4dc64d18a0d">unpack()</a>.</p>

</div>
</div>
<a id="affeb052a27b2eece6e9b5426e50070f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affeb052a27b2eece6e9b5426e50070f1">&#9670;&nbsp;</a></span>unpack() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void msgpack::unpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1object__handle.html">object_handle</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t *&#160;</td>
          <td class="paramname"><em>off</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>referenced</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemsgpack.html#a74841406f4ad1b1b1bf51d5290418697">unpack_reference_func</a>&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code><a class="el" href="v1_2cpp__config__decl_8hpp.html#a68eb5e9337cb3cdcc7da1f4ab5333e26">MSGPACK_NULLPTR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a> const &amp;&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="classmsgpack_1_1unpack__limit.html">unpack_limit</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> from a buffer. [obsolete]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The <a class="el" href="classmsgpack_1_1object__handle.html" title="The class holds object and zone.">object_handle</a> that contains unpacked data. </td></tr>
    <tr><td class="paramname">data</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the buffer. </td></tr>
    <tr><td class="paramname">off</td><td>The offset position of the buffer. It is read and overwritten. </td></tr>
    <tr><td class="paramname">referenced</td><td>If the unpacked object contains reference of the buffer, then set as true, otherwise false. </td></tr>
    <tr><td class="paramname">f</td><td>A judging function that <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a> refer to the buffer. </td></tr>
    <tr><td class="paramname">user_data</td><td>This parameter is passed to f. </td></tr>
    <tr><td class="paramname">limit</td><td>The size limit information of <a class="el" href="structmsgpack_1_1object.html" title="Object class that corresponding to MessagePack format object.">msgpack::object</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is obsolete. Use the reference inteface version of unpack functions instead of the pointer interface version. </p>

<p class="reference">References <a class="el" href="namespacemsgpack.html#af8c675c74116393a0b90e4dc64d18a0d">unpack()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
